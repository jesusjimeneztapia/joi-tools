{
  "object.and": "{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}",
  "object.assert": "{{#label}} is invalid because {if(#subject.key, `\"` + #subject.key + `\" failed to ` + (#message || \"pass the assertion test\"), #message || \"the assertion failed\")}",
  "object.base": "{{#label}} must be of type {{#type}}",
  "object.instance": "{{#label}} must be an instance of {{:#type}}",
  "object.length": "{{#label}} must have {{#limit}} key{if(#limit == 1, \"\", \"s\")}",
  "object.max": "{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, \"\", \"s\")}",
  "object.min": "{{#label}} must have at least {{#limit}} key{if(#limit == 1, \"\", \"s\")}",
  "object.missing": "{{#label}} must contain at least one of {{#peersWithLabels}}",
  "object.nand": "{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}",
  "object.oxor": "{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}",
  "object.pattern.match": "{{#label}} keys failed to match pattern requirements",
  "object.refType": "{{#label}} must be a Joi reference",
  "object.regex": "{{#label}} must be a RegExp object",
  "object.rename.multiple": "{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}",
  "object.rename.override": "{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists",
  "object.schema": "{{#label}} must be a Joi schema of {{#type}} type",
  "object.unknown": "{{#label}} is not allowed",
  "object.with": "{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}",
  "object.without": "{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}",
  "object.xor": "{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"
}
